[{"content":"格雷编码 被格雷编码的生成公式震惊了\n以三位格雷编码为例，⊕代表异或\n000 ⊕ 000 = 000 001 ⊕ 000 = 001 010 ⊕ 001 = 011 011 ⊕ 001 = 010 100 ⊕ 010 = 110 101 ⊕ 010 = 111 110 ⊕ 011 = 101 可以推导出如下公式： $gray_{i} = i \\oplus i\u0026raquo;1$\ngo 代码如下：\nfunc grayCode(n int) []int { var ans []int for i := 0; i \u0026lt; 1\u0026lt;\u0026lt;n; i++ { ans = append(ans, i^i\u0026gt;\u0026gt;1) } return ans } 与这道题相关联的 1238. 循环码排列 - 力扣（LeetCode）\ngray[0] = 0，则 gray[0] ⊕ start = start。 gray[i-1]与 gray[i]相差一个二进制位，则都与 start 异或后也只差一个二进制位。 func circularPermutation(n int, start int) []int { var ans []int for i := 0; i \u0026lt; 1\u0026lt;\u0026lt;n; i++ { ans = append(ans, i^i\u0026gt;\u0026gt;1^start) } return ans } ","date":"2023-02-23","permalink":"https://2yd.github.io/post/leetcode-89/","tags":["algorithm","leetcode","note","programming"],"title":"Leetcode 89：格雷编码"},{"content":"其它语言中都使用垃圾回收机制或要求程序员手动分配释放内存的方式来管理内存，而 rust 使用了另一种方式：所有权(ownership)\n以下以字符串 String 类型来解释所有权规则。\n内存与分配 与字符串字面量不同，String 类型支持可变可增长的文本片段，这也就意味着需要在堆上分配一块编译时未知大小的内存来存放内容。\nfn main() { let mut s = String::from(\u0026quot;hello\u0026quot;); s.push_str(\u0026quot;world\u0026quot;); println!(\u0026quot;{}\u0026quot;,s); } 为了实现这一过程需要执行如下两个操作：\n运行时向内存分配器请求内存 处理完一个 String 时将内存返回给内存分配器 第一个过程由我们完成，调用 String::from 时它的实现就请求了所需的内存。 而第二个过程则非常特别，内存在离开作用域后自动被释放。 比如如下代码段\n{ let s = String::from(\u0026quot;hello\u0026quot;); //申请内存 //可以使用s } //s被释放 //不可使用s 变量离开作用域后自动调用 drop 函数，将内存释放。\n移动 let s1 = String::from(\u0026quot;hello\u0026quot;); let s2 = s1; 这里 s2 和 s1 都指向了堆中的同一块区域，如果这两个变量离开作用域就会释放两次内存，这是不允许的。rust 为了解决这个问题，当 let s2 = s1 后会认为 s1 不再有效，因此不会在 s1 离开作用域后清理内存。这个操作就叫做 移动。所以如下代码块会报错\nlet s1 = String::from(\u0026quot;hello\u0026quot;); let s2 = s1; println!(\u0026quot;{}\u0026quot;,s1); 这里也隐含了 rust 不会自动创建深拷贝，任何自动的复制都可以认为不会影响性能。\n克隆 那我不想移动，我就想拷贝堆上的数据，这时候就要用 clone 函数。\nfn main() { let s1 = String::from(\u0026quot;hello\u0026quot;); let s2 = s1.clone(); println!(\u0026quot;{},{}\u0026quot;,s1,s2) } 这个时候不涉及到移动操作，所以两个变量都能使用。但这种情况下可能会造成较大的资源开销。\n栈上的数据：拷贝 fn main() { let x = 5; let y = x; println!(\u0026quot;{},{}\u0026quot;,x,y) } 对于栈上的数据，rust 认为其拷贝一般是迅速的，深浅拷贝没有区别，因此不涉及移动操作。\nrust 有一个叫做 Copy 的 trait，实现了这个 trait 的类型的变量在复制给其他变量后仍然可用。同时 rust 也不允许实现了 Drop trait 的类型实现 Copy trait。\n如下是实现了 Copy trait 的一部分类型：\n整数和浮点数，如 u32，f64 布尔类型 字符类型，char 仅包含实现了 Copy trait 类型的元组，如 (i32,f64) 所有权与函数 传参与赋值的规则类似，也会涉及到移动或拷贝\nfn main() { let s = String::from(\u0026quot;hello\u0026quot;); take_ownership(s); //移动 println!(\u0026quot;{}\u0026quot;,s); //报错 } fn take_ownership(s: String) { println!(\u0026quot;{}\u0026quot;,s) } //释放s 这里 s 发生了移动，因此在调用函数后不能再使用 s\nfn main() { let s = 5; make_copy(s); println!(\u0026quot;{}\u0026quot;,s); //5 } fn make_copy(s: i32) { println!(\u0026quot;{}\u0026quot;,s) } s 为 i32 类型，实现了 Copy trait，因此发生了拷贝而不是移动，调用函数后仍能使用 s。\n所有权与返回值 和传入参数的规则类似\nfn main() { let s1 = func1(); println!(\u0026quot;{}\u0026quot;,s1); let s2 = String::from(\u0026quot;world\u0026quot;); let s3 = func2(s2); println!(\u0026quot;{}\u0026quot;,s3); } fn func1() -\u0026gt; String { let s = String::from(\u0026quot;hello\u0026quot;); s } fn func2(s: String) -\u0026gt; String { println!(\u0026quot;{}\u0026quot;,s); s } 那我不想转移所有权，只想对值进行操作，比如获取字符串的长度，一个想法是返回一个元组。\nfn main() { let s1 = String::from(\u0026quot;hello\u0026quot;); let (s1,l) = get_length(s1); println!(\u0026quot;{s1},{l}\u0026quot;) } fn get_length(s: String) -\u0026gt; (String,usize) { let l = s.len(); (s,l) } 这不纯脱裤子放屁吗\u0026hellip;为了解决这个问题可以使用 引用\n","date":"2023-02-23","permalink":"https://2yd.github.io/post/rust-note-05/","tags":["rust","learning","note","programming"],"title":"Rust 笔记（5）：所有权"},{"content":"if、else、else if 和其他语言没有区别的条件判断。就是格式上条件没有括号，和 go 一样。\nlet 语句中使用 if 在 rust 中 if 语句是个表达式，所以可以用来绑定变量。\nfn main() { let condition = true; let a = if condition {3} else {4}; println!(\u0026quot;a={a}\u0026quot;) } 在这种用法下每个代码块都必须返回相同类型的值，因为编译器需要在编译时确定每个变量的类型。\n循环 loop 顾名思义，不加额外操作就会无限循环。\nfn main() { loop { println!(\u0026quot;loop again!\u0026quot;); } } loop 可以被 break 中断，神奇的是 break 可以接一个表达式，代表这个 loop 的返回值\u0026hellip;\nfn main() { let mut c = 0; let a = loop { c += 1; if c == 10 { break c*2 } }; println!(\u0026quot;a={a}\u0026quot;) //a=20 } rust 也有循环标签，break 加标签可以跳出指定的循环\nfn main() { let mut j = 0; 'outside: loop { j += 1; loop { j += 1; if j == 10 { break 'outside; } } } } while 平平无奇\nfn main() { let a = [1,2,3,4,5]; let mut i = 0; while i\u0026lt;5 { println!(\u0026quot;{}\u0026quot;,a[i]); i+=1; } } for for 循环就和其他语言不太一样了，和 python 倒是有点相似。\nfor 用于遍历一个集合，比如\nfn main() { let a = [1,2,3,4,5]; for e in a { println!(\u0026quot;{e}\u0026quot;) } } 还可以配合区间表达式来使用，太帅了我擦\nfn main() { for i in (1..=5).rev() { //rev函数用于反转区间 println!(\u0026quot;{i}\u0026quot;) //5 4 3 2 1 } } ","date":"2023-02-21","permalink":"https://2yd.github.io/post/rust-note-04/","tags":["rust","learning","note","programming"],"title":"Rust 笔记（4）：流程控制（条件分支和循环）"},{"content":"函数 命名遵循蛇形命名，即字母全部小写，单词用下划线分隔 参数必须注明类型 rust 不关心函数定义的位置，被调用时处在作用域就行。 fn main() { print_num_and_char(2,'c'); } fn print_num_and_char(num: i32, c: char) { println!(\u0026quot;number is {num}, character is {c}\u0026quot;); } rust 函数一个独特的特性就是函数由一系列语句和一个可选的表达式组成。\n语句和表达式 语句执行操作但不返回值，表达式计算并产生一个值。\n比如 let a=32 这就是个语句， 5+6 这就是个表达式。此外函数调用、宏调用和大括号创建一个新的块作用域都是表达式。\nfn main() { let y = { let x = 10; x + 10 }; println!(\u0026quot;y={y}\u0026quot;); //20 } 注意！ 表达式的结尾没有分号，加上就变成一条语句没有返回值了。\n明白了这个概念就可以写有返回值的函数了。\n有返回值的函数 返回值没有命名，但要用 -\u0026gt; 后加类型指明返回值的类型 函数的返回值等于函数体最后一个表达式的值，当然可以用 return 返回指定值，但大部分函数还是属于前者。 fn main() { let y = make_five(); println!(\u0026quot;y={y}\u0026quot;) } fn make_five() -\u0026gt; i32 { 5 } rust 的函数能写成这个鬼样子，太牛了\u0026hellip;\n","date":"2023-02-21","permalink":"https://2yd.github.io/post/rust-note-03/","tags":["rust","learning","note","programming"],"title":"Rust 笔记（3）：函数、语句和表达式"},{"content":"数组 长度固定，存储相同数据类型，不常用，一般用切片。\n以下是一些数组的声明方式和字面值\nvar p [3]int //[0,0,0] var q [3]int = [3]int{1, 2, 3} var r = [3]int{1, 2} //[1,2,0]，没初始化的都是零值 var s = [...]int{1, 2, 3, 4} //...代表根据元素个数自动生成数组长度 t := [...]int{0: 1, 4: 2} //[1 0 0 0 2] 索引:值 数组长度也是数据类型的一部分，也就是说 [3]int 和 [4]int 是不同的类型\nvar p [3]int var q [4]int = p //报错 如果两个数组的元素是可比较的且长度相同，那么这两个数组也是可比较的。当两个数组的元素完全相同时才返回 true。\nfunc main() { a := [2]int{1, 2} b := [...]int{2, 1} c := [...]int{1, 2} fmt.Println(a == b, a == c) //false true } 关于数组的传参：\n数组在 go 语言是值类型，也就是说默认值传递。\nfunc main() { a := [3]int{1, 2, 3} foo(a) fmt.Println(a) //[1 2 3] } func foo(a [3]int) { a[1] = 0 } 要想改变数组的值，就要指针传递。\nfunc main() { a := [3]int{1, 2, 3} foo(\u0026amp;a) fmt.Println(a) //[1 0 3] } func foo(a *[3]int) { a[1] = 0 } 值传递的时候不可避免地拷贝整个数组，很可能造成很大的资源开销，所以尽量使用指针。\n","date":"2023-02-21","permalink":"https://2yd.github.io/post/golang-note-06/","tags":["golang","learning","note","programming"],"title":"Golang 笔记（6）：数组"},{"content":"字符串与 byte 切片 字符串可以与 []byte 相互转换\nstr := \u0026quot;abc\u0026quot; b := []byte(str) s := string(b) 当然这会带来不必要的内存开销，go 为 string 和 []byte 提供了对应功能相同的函数，比如\nfunc main() { str := \u0026quot;abc\u0026quot; fmt.Println(strings.HasPrefix(str, \u0026quot;a\u0026quot;)) b := []byte{97, 98, 99} fmt.Println(bytes.HasPrefix(b, []byte{97})) } bytes 包提供了高效处理 []byte 的 Buffer 类型。\nfunc main() { var buf bytes.Buffer buf.WriteByte('[') nums := []int{1, 2, 3} for i, v := range nums { if i \u0026gt; 0 { buf.WriteByte(',') } fmt.Fprintf(\u0026amp;buf, \u0026quot;%d\u0026quot;, v) } buf.WriteByte(']') fmt.Println(buf.String()) } 当写入 ascii 时 WriteByte 已经足够，如果是其他字符比如 utf-8 编码的字符就要用 WriteRune。\n字符串与数字 要将整数转换为字符串，可以用 fmt.Sprintf 或strconv.Itoa\nnum := 100 str1 := fmt.Sprintf(\u0026quot;%d\u0026quot;, num) str2 := strconv.Itoa(num) FormatInt 和 FormatUint 可以按不同的进制转换数字。\nnum := 100 str := strconv.FormatInt(int64(num), 2) fmt.Println(str) //1100100 Sprintf 用于转换字符串更加灵活\nnum := 100 str := fmt.Sprintf(\u0026quot;x = %b\u0026quot;, num) fmt.Println(str) //x = 1100100 strconv 包的 Atoi 和 ParseInt 都可以把字符串转换成数字\nstr := \u0026quot;100\u0026quot; num1, err := strconv.Atoi(str) num2, err := strconv.ParseInt(\u0026quot;123\u0026quot;, 10, 64) 注意 ParseInt 的返回值始终是 int64，最后一个参数仅用作校验。\n","date":"2023-02-21","permalink":"https://2yd.github.io/post/golang-note-05/","tags":["golang","learning","note","programming"],"title":"Golang 笔记（5）：字符串的更多玩法"},{"content":" rust 中分为两种数据类型：标量（scalar）和复合（compound）。 98=rust 是静态类型语言，在编译时要确定所有变量的类型。当类型不确定时需要增加类型注解。\nlet guess: u32 = \u0026quot;42\u0026quot;.parse().expect(\u0026quot;Not a number\u0026quot;) 标量类型 整形 和 go 类似，rust 的整形分为 i8，i16，i32，i64，i128，对应的无符号类型为 u8，u16 以此类推。isize 和无符号类型 usize 在 64 位机器上占 64 位，32 位机器占 32 位。\n关于数字字面值：\n可以添加类型后缀 let x = 20u8;，此时 x 是 u8 类型 可以用 _ 做分隔符增加可读性，1_0000_0000 等价于 100000000 可以添加前缀表明进制 字面值 示例 十六进制 0xbeef 八进制 0o777 二进制 0b10010 单字节字符（u8） b\u0026rsquo;A' 浮点数 分为 f32 和 f64，默认 f64，和 go 一样，没什么特别的\n布尔值 每个编程语言都一样的布尔值，更没什么说的。\n字符类型 rust 中 char 类型占四个字节，代表一个 unicode，也就是说甚至可以支持 emoji。\nlet c: char = '😘'; 复合类型 元组 和 python 一样，可以看成一个不可变的数组。\n元组中的数据不一定是一样的类型。\nlet tup: (i32,f64,char)=(20,20.0,'😍'); 元组也支持解构（Destructuring） 操作。\nfn main() { let tup = (20,20.01,'😍'); let (x,y,z) = tup; println!(\u0026quot;{x},{y},{z}\u0026quot;); //20,20.01,😍 } 可以使用 . 加索引直接访问对应的元素。\nfn main() { let tup = (20,20.01,'😍'); let c = tup.2; println!(\u0026quot;{c}\u0026quot;) //😍 } 数组 数组中每个元素类型必须相同，而且长度固定。\n一些数组的声明和字面值\nlet a = [1,2,3,4,5]; let b: [i16; 5] = [1,2,3,4,5]; let c = [3;5]; //就是[3,3,3,3,3] 数组是在栈上分配的，可以用 a[i] 的方式访问数组中的元素。\n","date":"2023-02-20","permalink":"https://2yd.github.io/post/rust-note-02/","tags":["rust","learning","note","programming"],"title":"Rust 笔记（2）：数据类型"},{"content":"变量与可见性 rust 中变量使用 let 声明，同时默认这个变量不可变\nfn main() { let x = 10; println!(\u0026quot;x={x}\u0026quot;); x = 10; println!(\u0026quot;x={x}\u0026quot;); } 此时会报错，看得出 rust 的错误提示还是相当高级的哈\n| 2 | let x = 10; | - | | | first assignment to `x` | help: consider making this binding mutable: `mut x` 3 | println!(\u0026quot;x={x}\u0026quot;); 4 | x = 10; | ^^^^^^ cannot assign twice to immutable variable 变量名前加 mut 使其可变\nfn main() { let mut x = 10; println!(\u0026quot;x={x}\u0026quot;); x = 9; println!(\u0026quot;x={x}\u0026quot;); } 常量 常量使用 const 声明，和其他语言一样当然是不可变的。\nconst PI: f64 = 3.1415926 那常量和不可变变量又有什么区别呢？\n首先常量声明必须指明数据类型，其次常量可以声明在任何作用域，包括全局作用域，最后常量只能是常量表达式，不能是其他只能在运行时算出的值。\n隐藏（Shadowing） 当定义了一个与之前变量同名的变量，就说第一个变量被隐藏了。此时任何使用该变量名时使用的都是后定义的变量。\nfn main() { let x = 20; let x = x-10; { let x = x*10; println!(\u0026quot;x={x}\u0026quot;); //x=100 } println!(\u0026quot;x={x}\u0026quot;); //x=10 } ","date":"2023-02-20","permalink":"https://2yd.github.io/post/rust-note-01/","tags":["rust","learning","note","programming"],"title":"Rust 笔记（1）：变量与可变性、常量、隐藏"},{"content":"整数 整数分为 int， int8，int16，int32，int64。go 语言的类型非常严格，这几个都不能互相兼容参与运算，比如 int8 和 int32 一起运算时会报错，必须先经过显示转换。其他的类型也如此。 int8 代表占 8 位即 1 字节，以此类推。int 在 32 位机器占 32 位，64 位机器占 64 位。 a := 10 类型推断时 a 为 int 类型。 有对应的无符号类型，比如 uint8。 rune 是 int32 的别名，byte 是 uint8 的别名，可以互相替换。 func main() { var r rune = '啊' var a int32 = r fmt.Printf(\u0026quot;%c\u0026quot;, a) } uintptr 也是一种无符号整数类型，为一个指针的大小，常用于底层编程。 接下来是一些和整数有关的小 tips：\n% 取模运算符只能用于整数，结果始终与被除数保持相同。-5%3 和 -5%-3 的结果都是 -2.\ngo 语言还有个神奇的位运算符是 \u0026amp;^，顾名思义就是与非操作，可能处理 bitset 时候很有用。。。\n关于八进制和十六进制，看个代码段全懂了。\nfunc main() { a := 0777 fmt.Printf(\u0026quot;%d %[1]o %#[1]o %[1]O\u0026quot;, a) //511 777 0777 0o07774 b := 0xbeef fmt.Printf(\u0026quot;%d %[1]x %#[1]x %#[1]X\u0026quot;, b) //48879 beef 0xbeef 0XBEEF } 关于 rune 和 byte\nfunc main() { r := '呃' fmt.Printf(\u0026quot;%d %[1]c %[1]q\u0026quot;, r) //21571 呃 '呃' b := 'g' fmt.Printf(\u0026quot;%d %[1]c %[1]q\u0026quot;, b) //103 g 'g' } 浮点数 浮点数有 float32 和 float64，没有 float 和 double。 f := 1.1 f 的类型为 float64，也推荐在开发中使用 float64，精度更高范围更大，占的那点空间算什么。 没啥了 tips：\nfloat32 的精度真的很感人\nvar f float32 = 1 \u0026lt;\u0026lt; 24 fmt.Println(f == f+1) //true math 包里有常量给出 float32 和 float64 的最大值和非 0 最小值。直接把源码搬过来：\nconst ( MaxFloat32 = 0x1p127 * (1 + (1 - 0x1p-23)) // 3.40282346638528859811704183484516925440e+38 SmallestNonzeroFloat32 = 0x1p-126 * 0x1p-23 // 1.401298464324817070923729583289916131280e-45 MaxFloat64 = 0x1p1023 * (1 + (1 - 0x1p-52)) // 1.79769313486231570814527423731704356798070e+308 SmallestNonzeroFloat64 = 0x1p-1022 * 0x1p-52 // 4.9406564584124654417656879286822137236505980e-324 ) 这里的十六进制出现了 p，p 代表 2 的指数，p1023 就是 $2^{1023}$\n以下浮点数都是合法的：\nf1 := 1. f2 := .414 f3 := 6.022e23 f4 := 6.626e-34 复数 分为 complex64 和 complex128，分别由 float32 和 float64 组成。 x:=3+4i x 的类型为 complex128。 由于不常用所以也没啥好说的。 complex 内置函数可以用于生成复数，real 用于提取实部，imag 提取虚部。\nx := complex(3, -2) y := complex(4, 1) fmt.Println(x * y) //(14-5i) fmt.Println(real(x * y)) //14 fmt.Println(imag(x * y)) //-5 math/cmplx 包给了复数运算的函数\nfmt.Println(cmplx.Sqrt(-1)) //(0+1i) 布尔类型 和其他语言一样没啥好说的，就是 go 的布尔值不能转换成别的类型，就算是 int(b) 来了也不好使，非得转换的话用 if 判断。 字符串 go 语言里字符串是基本类型，想不到吧\nUTF-8 编码，太 international 了。 假设 str 是一个字符串，len(str) 返回字节数，str[i] 返回第 i 个字节。注意是字节不是字符，因为非 ascii 的 utf-8码点占两个以上的字节。 是个不可变类型。可以用 + 拼接字符串，但实际上返回了一个新字符串，原字符串还是没变的。所以 str[0]='s' 这样的写法会报错。 字符串也支持切片操作， str[i:j] 返回由 i 到 j（不包含）这几个字节组成的字符串。str[:j] 返回的就是 0 到 j-1 这几个字节的字符串。因为字符串不可变，所以两个字符串可以安全地公用一块内存，比如复制操作和这个切片操作都没有分配新的内存。 tips： unicode/utf8 包中的 DecodeRuneInString 可以用 utf-8 的方式解析字符串中的一个字符。\nfunc main() { str := \u0026quot;你好世界\u0026quot; fmt.Println(len(str)) //12，看得出utf-8编码下一个汉字占3个字节 cnt := 0 for i := 0; i \u0026lt; len(str); { r, size := utf8.DecodeRuneInString(str[i:]) fmt.Printf(\u0026quot;%c\u0026quot;, r) //你好世界 i += size cnt++ } fmt.Println(cnt) //4 } 统计字符数还有更方便的 RuneCountInString 函数\nfunc main() { str := \u0026quot;你好世界\u0026quot; fmt.Println(utf8.RuneCountInString(str)) } range 会隐式地用 utf-8 解析字符串，也可以直接用显式地把字符串转换成 rune 切片。\nfunc main() { str := \u0026quot;你好世界\u0026quot; for i := 0; i \u0026lt; len(str); i++ { fmt.Printf(\u0026quot;%c\u0026quot;, str[i]) //乱码 } for _, v := range str { fmt.Printf(\u0026quot;%c\u0026quot;, v) //你好世界 } r := []rune(str) for i := 0; i \u0026lt; len(r); i++ { fmt.Printf(\u0026quot;%c\u0026quot;, r[i]) //你好世界 } } 字符串的其他操作下个博客再说，太多了。\n常量 编译时就能知道的值，只能是布尔型、数字或字符串。 顾名思义，不可修改 const 经常用因式分解式语法来声明。\nconst ( blue = iota green red yellow ) 等价于\nconst ( blue = 1 green = 2 red = 3 yellow = 4 ) iota 叫做常量生成器，详细的规则很复杂，参考 Go语言基础之iota\n还有一类神奇的常量叫无类型常量，和汇编里的立即数差不多意思。说的挺玄乎，看俩例子就懂了。\nvar i int64 = 1.0 var f float64 = math.Pi var x float32 = math.Pi var y complex128 = math.Pi 不是说好的 go 类型检查很严格的，为什么 1.0 这么明显的浮点数还能赋给整形，math.Pi 还能给不同类型的变量赋值！\n其实这里的 1.0 和 math.Pi 就是无类型常量，在赋值过程中编译器将无类型常量转换为左侧变量需要的类型，为的就是避免不必要的精度损失。\n在转换过程中也要求目标类型能够表示原值，若溢出就会发生编译错误。\ne := int8(32767) //编译不通过 ","date":"2023-02-20","permalink":"https://2yd.github.io/post/golang-note-04/","tags":["golang","learning","note","programming"],"title":"Golang 笔记（4）：基础类型们"},{"content":"包 包的导入 一个小例子： src/main/main.go\npackage main import p \u0026quot;test/ptest\u0026quot; func main() { p.PrintHelloWorld() } ptest/helloworld.go\npackage ptest import \u0026quot;fmt\u0026quot; func PrintHelloWorld() { fmt.Println(\u0026quot;hello world!\u0026quot;) } 很简单易懂，写几个补充说明\np.PrintHelloWorld() 这个 p 叫做短名字，默认的短名字是导入路径的最后一段，这里是 ptest，也可以向示例这样取别名。 首字母大写的变量或函数代表可以导出，也就是说可以在别的包使用 包初始化 先初始化包级别的变量，然后执行 init 函数。 按导入顺序依次初始化包。比如 p 导入 q，q 会在 p 之前初始化。 作用域 大体上和其他语言没有区别嘛，而且很直观，不费劲叙述了\n","date":"2023-02-19","permalink":"https://2yd.github.io/post/golang-note-03/","tags":["golang","learning","note","programming"],"title":"Golang 笔记（3）：包、作用域"},{"content":"可能会随口聊两句关于这个社团的印象，排名不分先后。\n紺碧studio\nTHE OTHER FLOWER\n东方团体，vocal是花たん，好听。\nALiCE\u0026rsquo;S EMOTiON\nREDALiCE主催，可以欣赏到他早期的曲子\n少女フラクタル\nCYCLIK CONTROL\nINTX Rec.\nAcuticNotes\nAn一个人组成的音乐团体，纯纯的artcore\nELFENSJóN\nHardcore Armament Reloaded\n音召缶\nRJT Music\nReal Japanese Trance\nZYTOKINE\nはちみつれもん\nOn Prism Records\n专做术立口，曲风大多很清新，我很中意。\nMEGAREX\nGET IN THE RING\nLilium Records\n比较老牌的社团，曲风很多变。\nSKETCH UP! Recordings\nSPACELECTRO\n东方社团，专做EDM改编\nNiZi RiNGO\nIllegal Wave Records\n6th主催，比较黑暗凶残的hardcore\nExist Twinkle\nBlackY\u0026rsquo;s BEATFLOOR\nYoohsic Roomz\n和上面那个一样一看就知道是谁的社团\nRound Wave Crusher\ndat file records\nFor You Sounds\nKirara Records\nHappy Hardcore比较多，快乐。\nSensitive Heart\nHardcore Tano*C\n越来越不Hardcore\nNext Reflection\nwavforme\n个人心目中封面做的最好看的社团之一，成员也都很有实力。\nFujimi lndustry Records\n比较underground的厂牌，所以会有很多听起来很与众不同甚至怪异的歌，但也因此很有新鲜感。\nRiparia Records\nDiverse System\n成员个个都是国家队级别\nsuwawa Records\nRolling Contact\n天音的别名义，专做EDM各种曲风的东方曲，很有才华。\nVIVID HARDCORE\n专做happy hardcore，双倍的快乐。\nPsycho Filth Records\n速核，快快快。\nJapanese Stream Hardcore\nDJ MYOSUKE主催，所以硬度有保证。。。\nSuganoMusic\nBinzokomegane Girls Union\nLogin Records\nLoquartz\nRTTF Records\nDACHiTRAX\n因为对かめりあ的喜爱而创立的社团，音乐也都是模仿他的风格。\n","date":"2023-02-06","permalink":"https://2yd.github.io/post/music-listened/","tags":["music"],"title":"记录一下那些听过的社团、厂牌或其他"},{"content":"指针 从c语言那里捡来的，基本没什么区别。简单写一下注意点\n指针类型是*type，比如*int\nx是int类型变量，\u0026amp;x获取指向x的指针，类型为*int。假如这个指针叫p，*p获取这个指针指向的变量的值。\nx := 1 p := \u0026amp;x fmt.Println(*p)//1 *p += 2 fmt.Println(x) //2 func main() { x := 1 incr(\u0026amp;x) //x=2 fmt.Println(incr(\u0026amp;x)) //3 } func incr(p *int) int { //c族语言不得不品尝的指针传递 *p++ return *p } 指针的零值是nil。当两个指针进行比较时，只有它们指向同一个变量或都是nil时才返回true。\nnew函数 new是go的内置函数，new(type)返回一个指向type类型，值为零值的指针。没什么特别的，可以看成方便的语法糖。\n下面两个函数的功能是一样的：\nfunc newInt01() *int { return new(int) } func newInt02() *int { var a int return \u0026amp;a } 赋值 多重赋值 go语言支持多重赋值！\nfunc gcd(x, y int) int { //辗转相除法求公约数 for y != 0 { x, y = y, x%y } return x } //有些操作会额外产生一个变量指示操作是否成功 v, ok = m[key] //map查询 v, ok = x.(T) //类型断言 v, ok = \u0026lt;-ch //通道接收 隐式赋值 说这么玄乎，就是不用赋值号一个一个赋值呗，比如return语句，还有ints := []int{1,2,3}\n可赋值性 越说越玄乎了，就是赋值号两篇类型必须精准匹配，nil可以赋值给任何接口变量或引用类型（以后会见到），常量的规则会更灵活些。\n类型声明 type 自定义类型 底层类型\n比如\ntype weight float64 type height float64 这里 weight、height、float64都是互不相同的类型，无法一起赋值或运算，必须通过显式类型转换，比如 weight(f)\n","date":"2023-02-04","permalink":"https://2yd.github.io/post/golang-note-02/","tags":["golang","learning","note","programming"],"title":"Golang笔记（2）：指针、new函数、赋值"},{"content":"不会记录详细的使用方法，简明记录注意事项、特殊用法以及遇到的坑。\n格式 golang为了“简洁和优雅”规定了很严格的格式规范，这里只列出一些凤毛麟角。\n分号 golang编译器会自动为每一条语句末尾添加分号，不需要也不建议手动添加。 如果一行需要多条语句则需要手动添加分号，可能会在for循环和if条件中使用，其他情况不建议这么写。\n大括号 golang中第一个大括号必须不换行，因为会自动添加分号换行就报错。我喜欢\nfunc main() { // 编译通过 } func main() { //编译不通过 } 注释 虽然有/* 块注释 */，但建议全部使用// 单行注释。块注释一般用于包注释，方便在godoc指令下生成文档。\n变量 变量声明 变量声明了就必须使用，否则报错\n变量声明了就必须使用，否则报错\n变量声明了就必须使用，否则报错\n基础款：\nvar num int //注意数据类型（int）的位置 num = 10 var num1, num2 int //也ok 为什么数据类型要放在后面呢，可以看Go\u0026rsquo;s Declaration Syntax这篇博客，简而言之是为了更好的可读性。\n声明并初始化：\nvar num = 10 //数据类型可以省略，编译器会自动推断 var num int32 = 10 //当然不要推断出来的int类型也可以 var num1, num2 = 10, 20 //并行赋值 var num3, string1 = 30, \u0026quot;hello world\u0026quot; //类型不一样也ok 再简化一点：（短变量赋值）\nnum := 10 //这里就绝对不能写数据类型了 num1, num2 := 10, 20 num3, string1 := 30, \u0026quot;hello world\u0026quot; 短变量赋值的左侧不一定全是新变量，若原变量已声明则效果等同于赋值。同时左侧必须至少有一个新变量。\nvar num4 int num4, num5 := 20,30 golang有很多“因式分解”式语法，比如变量也可以这么声明。\nvar ( num = 10 num2 = 20 num3 = 30 ) 变量的默认值 如果变量生成时没有初始化，默认值为其数据类型的零值。\nfunc main() { var num int fmt.Println(num) //0 } 可导出与不可导出 标识符首字母大写表示可以导出，相当于其他语言中的public，可以在其他包使用。\n标识符首字母小写表示不可导出，相当于其他语言中的private，不可以在其他包使用。\n关于包以后会在其他blog中详细说明。\n无效的标识符 2yd （数字开头）\ninterface（关键字或保留字），但是预定义标识符是可以使用的，下面的语句就是合法的\nvar append int append = 20 a+b（运算符）\n空白标识符 空白标识符为_，任何数据类型都可以给它赋值，赋值后该值被舍弃。由于golang中所有变量都至少被使用一次，_就可以用来接受不需要的赋值，比如在range中就经常使用。\narray := [5]int{1,3,5,7,9} sum := 0 for _, val := range array { sum += val } 命名规范 尽可能简洁，不要多余的说明，不需要在标识符中包含包名。 不要下划线，统统驼峰命名。 一些约定俗成或硬性规定，比如接口标识符通常以I开头或er结尾，标识符大写表示可以导出……以后会出现很多。 常量 顾名思义，常量的值是不能改变的，否则报编译时错误。\n常量声明 const PI = 3.1415926 //常量声明必须初始化，数据类型依旧可省略 const Ln2 = 0.693147180559945309417232121458\\ 176568075500134360255254120680009 //反斜杠可以作为连接符 const male, female = 0, 1 //并行赋值 const ( //因式分解式声明 Monday, Tuesday, Wednesday = 1, 2, 3 Thursday, Friday, Saturday = 4, 5, 6 ) 常量的初始化 常量声明时必须初始化。由于在常量声明编译期间其他自定义函数都是未知，因此不能用自定义函数返回值初始化常量，但是内置函数比如len()可以。\niota 当常量需要被当作枚举值时可以通过iota简化代码：\nconst ( type00 = 0 type01 = 1 type02 = 2 type03 = 3 type04 = 4 ) 等价于\nconst ( type00 = iota type01 type02 type03 type04 ) 实际上iota的规则非常复杂，可以参考三分钟看透iota。\n","date":"2023-02-02","permalink":"https://2yd.github.io/post/golang-note-01/","tags":["golang","learning","note","programming"],"title":"Golang笔记（1）：格式、变量与常量"},{"content":"Markdown笔记，用自己的方式记录Markdown语法，也可能作为cheat sheat。使用的编辑工具为Typora，如果使用其他编辑工具可能与这篇blog描述有所出入。\n先来一段舒适的音乐 段落 使用空白行将文本进行分割。目前Typora等markdown编辑程序都会自动实现这个过程，不过多赘述。需要注意在Markdown中最好不要使用空格与Tab进行缩进。\n换行 在一行的末尾打两个空格并回车即可创建换行。也可以使用html的换行标签\u0026lt;br\u0026gt;进行换行。\n在Typora等Markdown等文本编辑器中，回车代表创建段落，shift+回车代表换行，这与平时的使用习惯可能有所不同。有时因为段落问题会导致Markdown格式很奇怪，就有可能是这个原因造成的。\n分隔线 单独一行上使用三个以上的星号(*)、下划线(_)或破折号(-)创建分隔线，效果上没有区别。为保证兼容性最好前后都添加空行。\n字体 基本使用：_文本_或*文本*使 文本 变为斜体，__文本__或**文本**使得 文本 变为粗体，~~文本~~为文本加删除线。\n简要补充：\n斜体和加粗可以同时使用，比如***文本***或**_文本_**都可以使得 文本 变为斜体加粗。更推荐**_文本_**使语法更清晰。\n这些语法当然是可以跨越多个词语的，for example。\n如果文本周围没有空格分隔，比如这是__一句__文本，这种情况下__下划线__会失效，请全部使用星号。\n引用 在需要引用的内容前面加一个\u0026gt;即可，比如这句话就就在一个引用块中。\n简要补充：\n引用块是可以嵌套的，多加一个\u0026gt;即可，效果如下\n禁止套娃\n禁止套娃\n引用块中支持其他的Markdown格式，这篇blog中随处可见。\n代码 使用反引号(`)标识单行代码，使用一对三个反引号标识一块代码。第一组反引号后加语言名可以实现对应的语法高亮。具体实例下面会有很多的（\n标题 标题分为一到六级，一级标题格式# 标题，六级标题格式###### 标题，以此类推。\n简要补充：\n也可以在文本下方添加任意数量的=号标识一级标题，-号标识二级标题\n为了兼容考虑需要在#与标题之间使用空格隔开。\n标题文本不能再加粗，但可以加斜体或删除线。\n标题可以创建编号，格式为### 一个标题 {#一个编号}，可以配合下面的链接实现跳转。\n链接 最基本的使用：[链接显示的文本](地址)，比如哔哩哔哩。\n根据语法的不同可以进行如下区分：\n超链接 [链接显示的文本](地址)，就是上面那个最基本的使用方法。\n简要补充：\n[]中的文本支持加粗斜体删除线等操作，代码格式也可以。\nfmt.Println(\u0026quot;Hello World\u0026quot;) ←点一下\n可以为链接加title，格式为[链接显示的文本](地址 \u0026quot;title\u0026quot;)，title可以用双引号、单引号或括号包裹。效果为鼠标移上去之后显示的文本。比如哔哩哔哩\n可以配合标题链接使用，地址改成对应的标签就行了，比如点我回到链接标题。\n网址和Email \u0026lt;网址或者email\u0026gt;，将其变成可以点击的链接。\n比如：https://www.hust.edu.cn u114514@hust.edu.cn\n引用链接 第一部分：[链接显示的文本][标签]\n第二部分：[标签]: 地址，这部分不会被Markdown渲染出来，大部分人喜欢将这个部分放在最末尾。 每个部分的名字都是乱起的，怎么好记怎么来。\n示例：\n[哔哩哔哩][1] [1]: https://www.acfun.cn 渲染效果：\n哔哩哔哩\n不太简要的补充说明：\n第二部分其实不需要放在第一部分之前，只不过实际使用中更习惯放在后面。 标签不区分大小写，可以包含数字、字母、标点、空格。 第一部分中链接显示的文本和标签可以使用一个空格隔开。 第二部分中的地址也是可以加title的，格式和超链接相同，比如[1]: www.acfun.cn \u0026quot;ニコニコ動画\u0026quot;。 第二部分冒号后至少需要一个空格分隔。 图片 ![图片文本](图片地址)，很简单吧。[![图片文本](图片地址)](地址)就可以给图片加链接了，也很简单吧。图片文本和html的img标签里的alt功能差不多，比如图片炸了就会显示出来。\n←点一下\n图片本质上也是个链接，因此也可以有引用链接的格式，和链接的引用链接差不多就不再赘述了。\n列表 无序列表 在每个列表项前加*\n第一项 第二项 第三项 有序列表 在每个列表项前加数字和句点\n第一项 第二项 第三项 不太简要的补充：\n有序列表的序号不一定要严格按递增顺序排序，但一定要以1.开头，最后渲染的时候仍然会渲染为1. 2. \u0026hellip;的格式。\n1. 第一项 32. 第二项 15. 第三项 15. 第四项 这种写法也是可以的，属于合法但有病。\n列表可以嵌套。比如就可以在这个有序列表里再嵌套一个无序列表：\n只需要多缩进四个空格或一个tab就行了，但是经过测试三个空格也可以 嵌套一般不超过三个，否则格式会很混乱 列表里也可以插入其他元素，需要将改元素多缩进四个空格或一个tab，但是经过测试三个空格也可以。比如插入一个引用：\n一个引用\n或者一个图片\n或者一个代码块\nimport \u0026quot;fmt\u0026quot; func main() { fmt.Println(\u0026quot;Hello world!\u0026quot;) } 任务列表 每一项前加 - [ ]，如果表示已完成就加 - [x]\nBlog搭建 Blog部署 发布一万篇Blog 表格 格式用语言描述太难了，直接看下面的代码块：\n| Syntax | Description | Test Text | | :--- | :----: | ---: | | Header | Title | Here's this | | Paragraph | Text | And more | 其中:---代表左对齐， :---:代表中对齐, ---:代表右对齐 一般没人会选择手打表格，请使用Markdown Tables generator或者Markdown编辑工具自带的表格生成工具来创建表格。\nemoji 两个冒号之间加emoji名字😋，具体可以查阅Complete list of github markdown emoji markup\nLaTeX数学公式块 在latex公式两侧使用$$包围，latex的语法就不能在这篇Blog里展开说了。。。\n$$ \\varGamma(x)=\\frac{\\int_{\\alpha}^{\\beta}g(t)(x-t)^2\\text{d}t}{\\phi(x)\\sum_{i=0}^{N-1}\\omega_i}\\tag{2} $$\nHTML Markdown支持直接嵌入html标签\n","date":"2023-01-31","permalink":"https://2yd.github.io/post/markdown-note/","tags":["markdown","note","learning"],"title":"Markdown笔记"},{"content":"第一条blog祭天 ","date":"2023-01-30","permalink":"https://2yd.github.io/post/first-post/","tags":["test"],"title":"第一条blog"}]